<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deriv Auto Trader Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Syne:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #131825;
            --bg-tertiary: #1a1f2e;
            --accent-primary: #00e5cc;
            --accent-secondary: #7c3aed;
            --accent-danger: #ef4444;
            --accent-success: #10b981;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --border-color: #1e293b;
            --shadow-glow: rgba(0, 229, 204, 0.15);
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
        }

        .bg-gradient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 20%, rgba(124, 58, 237, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 229, 204, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            box-shadow: 0 4px 20px var(--shadow-glow);
        }

        .logo {
            font-family: 'Syne', sans-serif;
            font-size: 24px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-danger);
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--accent-success);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 4px 20px var(--shadow-glow);
        }

        .card-title {
            font-family: 'Syne', sans-serif;
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 15px;
            color: var(--accent-primary);
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input, select {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px var(--shadow-glow);
        }

        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-glow);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: var(--accent-danger);
        }

        .btn-success {
            background: var(--accent-success);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            transition: 0.4s;
            border-radius: 26px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: var(--text-secondary);
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-color: var(--accent-primary);
        }

        input:checked + .slider:before {
            transform: translateX(24px);
            background-color: var(--text-primary);
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
        }

        .market-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .market-card {
            background: var(--bg-tertiary);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .market-card:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .market-card.active {
            border-color: var(--accent-primary);
            background: linear-gradient(135deg, rgba(0, 229, 204, 0.1), rgba(124, 58, 237, 0.1));
        }

        .market-name {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .market-price {
            font-size: 16px;
            color: var(--accent-primary);
            font-weight: 700;
        }

        .signal-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            margin-top: 4px;
        }

        .signal-badge.buy {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-success);
        }

        .signal-badge.sell {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-danger);
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .trades-table th {
            background: var(--bg-tertiary);
            padding: 10px;
            text-align: left;
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-color);
        }

        .trades-table td {
            padding: 12px 10px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .trades-table tr:hover {
            background: var(--bg-tertiary);
        }

        .profit {
            color: var(--accent-success);
            font-weight: 600;
        }

        .loss {
            color: var(--accent-danger);
            font-weight: 600;
        }

        .log-container {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
            border: 1px solid var(--border-color);
        }

        .log-entry {
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: var(--text-secondary);
            margin-right: 10px;
        }

        .strategy-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .strategy-item {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s ease;
        }

        .strategy-item:hover {
            border-color: var(--accent-primary);
        }

        .strategy-name {
            font-size: 12px;
            font-weight: 600;
        }

        .timeframe-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .timeframe-tab {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .timeframe-tab:hover {
            border-color: var(--accent-primary);
        }

        .timeframe-tab.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-color: var(--accent-primary);
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .stat-grid {
                grid-template-columns: 1fr;
            }
        }

        .loading-spinner {
            border: 3px solid var(--bg-tertiary);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .signal-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .signal-item {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 8px;
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .signal-market {
            font-weight: 600;
            font-size: 13px;
        }

        .signal-tf {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .signal-details {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
        }

        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            animation: slideIn 0.3s ease-out;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            min-width: 300px;
        }

        .toast.success {
            border-left: 4px solid var(--accent-success);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), var(--bg-secondary));
        }

        .toast.error {
            border-left: 4px solid var(--accent-danger);
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), var(--bg-secondary));
        }

        .toast.warning {
            border-left: 4px solid #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), var(--bg-secondary));
        }

        .toast.info {
            border-left: 4px solid var(--accent-primary);
            background: linear-gradient(135deg, var(--shadow-glow), var(--bg-secondary));
        }

        .toast-icon {
            font-size: 24px;
            line-height: 1;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 700;
            font-size: 14px;
            margin-bottom: 4px;
            font-family: 'Syne', sans-serif;
        }

        .toast-message {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .toast-close {
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 20px;
            line-height: 1;
            padding: 0 4px;
            transition: color 0.2s;
        }

        .toast-close:hover {
            color: var(--text-primary);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .toast.removing {
            animation: slideOut 0.3s ease-in forwards;
        }

        /* Pulse animation for updates */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px var(--accent-primary); }
            50% { box-shadow: 0 0 20px var(--accent-primary); }
        }

        .update-flash {
            animation: pulse-glow 0.5s ease-in-out;
        }

        /* Live update indicator */
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--accent-success);
            font-weight: 600;
        }

        .live-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-success);
            animation: pulse 2s infinite;
        }

        @media (max-width: 768px) {
            .toast-container {
                left: 20px;
                right: 20px;
                max-width: none;
            }

            .toast {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>
    <div class="bg-gradient"></div>
    
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">DERIV AUTO TRADER</div>
            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                <div class="connection-status">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <input type="password" id="apiToken" placeholder="Enter Deriv API Token" style="width: 250px;">
                <button class="btn" onclick="connectToDerivAPI()">Connect</button>
                <button class="btn btn-danger" onclick="disconnectFromDerivAPI()">Disconnect</button>
            </div>
        </div>

        <!-- Main Grid -->
        <div class="grid">
            <!-- Account Info -->
            <div class="card" id="accountCard">
                <div class="card-title">
                    Account Dashboard
                    <span class="live-indicator" id="accountLive" style="display: none;">
                        <span class="live-dot"></span>LIVE
                    </span>
                </div>
                <div class="stat-grid">
                    <div class="stat-item">
                        <div class="stat-label">Balance</div>
                        <div class="stat-value" id="balance">$0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Today P/L</div>
                        <div class="stat-value" id="todayPL">$0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Total Trades</div>
                        <div class="stat-value" id="totalTrades">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Win Rate</div>
                        <div class="stat-value" id="winRate">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Active Trades</div>
                        <div class="stat-value" id="activeTrades">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Status</div>
                        <div class="stat-value" id="botStatus">STOPPED</div>
                    </div>
                </div>
            </div>

            <!-- Trade Parameters -->
            <div class="card">
                <div class="card-title">Trade Parameters</div>
                <div class="input-group">
                    <label class="input-label">Stake Amount ($)</label>
                    <input type="number" id="stakeAmount" value="1" step="0.1" min="0.35">
                </div>
                <div class="input-group">
                    <label class="input-label">Trade Duration</label>
                    <select id="durationType">
                        <option value="ticks">Ticks</option>
                        <option value="seconds">Seconds</option>
                        <option value="minutes" selected>Minutes</option>
                    </select>
                </div>
                <div class="input-group">
                    <label class="input-label">Duration Value</label>
                    <input type="number" id="durationValue" value="1" min="1">
                </div>
                <div class="input-group">
                    <label class="input-label">Max Concurrent Trades</label>
                    <input type="number" id="maxTrades" value="3" min="1" max="10">
                </div>
            </div>

            <!-- Risk Management -->
            <div class="card">
                <div class="card-title">Risk Management</div>
                <div class="control-row">
                    <span>Risk Manager</span>
                    <label class="switch">
                        <input type="checkbox" id="riskManagerToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="input-group">
                    <label class="input-label">Max Loss ($)</label>
                    <input type="number" id="maxLoss" value="10" step="1">
                </div>
                <div class="input-group">
                    <label class="input-label">Max Win ($)</label>
                    <input type="number" id="maxWin" value="50" step="1">
                </div>
                <div class="input-group">
                    <label class="input-label">Min Win ($)</label>
                    <input type="number" id="minWin" value="5" step="1">
                </div>
                <div class="input-group">
                    <label class="input-label">Trade Run Limit</label>
                    <input type="number" id="tradeRunLimit" value="100" step="1">
                </div>
            </div>
        </div>

        <!-- Martingale Settings -->
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-title">Martingale System</div>
            <div class="control-row">
                <span>Enable Martingale</span>
                <label class="switch">
                    <input type="checkbox" id="martingaleToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;">
                <div class="input-group">
                    <label class="input-label">Multiplier</label>
                    <input type="number" id="martingaleMultiplier" value="2" step="0.1" min="1.1">
                </div>
                <div class="input-group">
                    <label class="input-label">Max Steps</label>
                    <input type="number" id="martingaleSteps" value="3" min="1" max="10">
                </div>
                <div class="input-group">
                    <label class="input-label">Reset After</label>
                    <select id="martingaleReset">
                        <option value="win">Win</option>
                        <option value="maxsteps">Max Steps</option>
                        <option value="both" selected>Both</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Strategy Selection -->
        <div class="card" style="margin-bottom: 20px;">
            <div class="card-title">Active Strategies</div>
            <div class="strategy-selector">
                <div class="strategy-item">
                    <span class="strategy-name">EMA Crossover</span>
                    <label class="switch">
                        <input type="checkbox" class="strategy-toggle" data-strategy="ema_crossover" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="strategy-item">
                    <span class="strategy-name">MACD SMA Cross</span>
                    <label class="switch">
                        <input type="checkbox" class="strategy-toggle" data-strategy="macd_sma" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="strategy-item">
                    <span class="strategy-name">Pin Bar Rejection</span>
                    <label class="switch">
                        <input type="checkbox" class="strategy-toggle" data-strategy="pin_bar" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="strategy-item">
                    <span class="strategy-name">Engulfing Fade</span>
                    <label class="switch">
                        <input type="checkbox" class="strategy-toggle" data-strategy="engulfing">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="strategy-item">
                    <span class="strategy-name">Inside Bar Breakout</span>
                    <label class="switch">
                        <input type="checkbox" class="strategy-toggle" data-strategy="inside_bar">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="strategy-item">
                    <span class="strategy-name">Doji MACD Divergence</span>
                    <label class="switch">
                        <input type="checkbox" class="strategy-toggle" data-strategy="doji_macd">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="strategy-item">
                    <span class="strategy-name">Volume Spike</span>
                    <label class="switch">
                        <input type="checkbox" class="strategy-toggle" data-strategy="volume_spike">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Market Selection & Signals -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
            <div class="card">
                <div class="card-title">Markets & Prices</div>
                <div class="timeframe-tabs">
                    <div class="timeframe-tab active" onclick="selectTimeframe('1m')">1 Min</div>
                    <div class="timeframe-tab" onclick="selectTimeframe('3m')">3 Min</div>
                    <div class="timeframe-tab" onclick="selectTimeframe('5m')">5 Min</div>
                </div>
                <div class="market-grid" id="marketGrid"></div>
            </div>

            <div class="card">
                <div class="card-title">Live Signals</div>
                <div class="signal-list" id="signalList">
                    <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                        Waiting for signals...
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="card" style="margin-bottom: 20px;">
            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                <button class="btn btn-success" onclick="startBot()" id="startBtn">
                    START TRADING
                </button>
                <button class="btn btn-danger" onclick="stopBot()" id="stopBtn">
                    STOP TRADING
                </button>
                <button class="btn btn-secondary" onclick="resetBot()">
                    RESET BOT
                </button>
                <button class="btn btn-secondary" onclick="clearHistory()">
                    CLEAR HISTORY
                </button>
            </div>
        </div>

        <!-- Active Trades -->
        <div class="card" style="margin-bottom: 20px;" id="activeTradesCard">
            <div class="card-title">
                Active Trades
                <span class="live-indicator" id="activeTradesLive" style="display: none;">
                    <span class="live-dot"></span>LIVE
                </span>
            </div>
            <div style="overflow-x: auto;">
                <table class="trades-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Market</th>
                            <th>Type</th>
                            <th>Stake</th>
                            <th>Entry</th>
                            <th>Current</th>
                            <th>P/L</th>
                            <th>Strategy</th>
                            <th>Time</th>
                        </tr>
                    </thead>
                    <tbody id="activeTradesTable">
                        <tr><td colspan="9" style="text-align: center; color: var(--text-secondary);">No active trades</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Trade History -->
        <div class="card" style="margin-bottom: 20px;" id="tradeHistoryCard">
            <div class="card-title">
                Trade History
                <span class="live-indicator" id="tradeHistoryLive" style="display: none;">
                    <span class="live-dot"></span>UPDATED
                </span>
            </div>
            <div style="overflow-x: auto;">
                <table class="trades-table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Market</th>
                            <th>Type</th>
                            <th>Stake</th>
                            <th>Entry</th>
                            <th>Exit</th>
                            <th>P/L</th>
                            <th>Strategy</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody id="tradeHistoryTable">
                        <tr><td colspan="9" style="text-align: center; color: var(--text-secondary);">No trade history</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- System Log -->
        <div class="card">
            <div class="card-title">System Log</div>
            <div class="log-container" id="systemLog">
                <div class="log-entry">
                    <span class="log-time">[00:00:00]</span>
                    <span>System initialized. Ready to connect.</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Trading Bot State
        const state = {
            ws: null,
            connected: false,
            authorized: false,
            botRunning: false,
            markets: [
                'R_10', 'R_25', 'R_50', 'R_75', 'R_100',
                '1HZ10V', '1HZ25V', '1HZ50V', '1HZ75V', '1HZ100V',
                'BOOM300N', 'BOOM500N', 'BOOM1000N',
                'CRASH300N', 'CRASH500N', 'CRASH1000N',
                'frxAUDUSD', 'frxEURUSD', 'frxGBPUSD', 'frxUSDJPY',
                'frxXAUUSD' // Gold
            ],
            focusMarket: 'R_100',
            selectedTimeframe: '1m',
            marketPrices: {},
            candleData: {}, // {market: {1m: [], 3m: [], 5m: []}}
            signals: [],
            activeTrades: [],
            tradeHistory: [],
            pendingTrades: {},
            accountBalance: 0,
            accountCurrency: 'USD',
            todayPL: 0,
            totalTrades: 0,
            wins: 0,
            losses: 0,
            activeStrategies: {
                ema_crossover: true,
                macd_sma: true,
                pin_bar: true,
                engulfing: false,
                inside_bar: false,
                doji_macd: false,
                volume_spike: false
            },
            indicators: {}, // Cached indicator values
            martingaleStep: 0,
            tradeRunCount: 0,
            lastTradeTime: 0,
            lastSignal: null
        };

        // Technical Indicator Calculations
        const Indicators = {
            EMA: function(data, period) {
                if (data.length < period) return null;
                const multiplier = 2 / (period + 1);
                let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
                
                for (let i = period; i < data.length; i++) {
                    ema = (data[i] - ema) * multiplier + ema;
                }
                return ema;
            },

            SMA: function(data, period) {
                if (data.length < period) return null;
                return data.slice(-period).reduce((a, b) => a + b, 0) / period;
            },

            MACD: function(data, fast = 12, slow = 26, signal = 9) {
                if (data.length < slow) return null;
                
                const emaFast = this.EMA(data, fast);
                const emaSlow = this.EMA(data, slow);
                const macdLine = emaFast - emaSlow;
                
                // For signal line, we'd need history - simplified here
                return { macd: macdLine, signal: 0, histogram: macdLine };
            },

            RSI: function(data, period = 14) {
                if (data.length < period + 1) return null;
                
                let gains = 0, losses = 0;
                for (let i = 1; i <= period; i++) {
                    const change = data[data.length - i] - data[data.length - i - 1];
                    if (change > 0) gains += change;
                    else losses -= change;
                }
                
                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            }
        };

        // Strategy Implementations
        const Strategies = {
            emaCrossover: function(candles, timeframe) {
                if (candles.length < 30) return null;
                
                const closes = candles.map(c => c.close);
                const ema9 = Indicators.EMA(closes, 9);
                const ema29 = Indicators.EMA(closes, 29);
                
                if (!ema9 || !ema29) return null;
                
                const prevCloses = candles.slice(0, -1).map(c => c.close);
                const prevEma9 = Indicators.EMA(prevCloses, 9);
                const prevEma29 = Indicators.EMA(prevCloses, 29);
                
                const lastCandle = candles[candles.length - 1];
                
                // Bullish crossover with candle close above
                if (prevEma9 <= prevEma29 && ema9 > ema29 && lastCandle.close > ema9) {
                    return { type: 'CALL', strategy: 'EMA Crossover', confidence: 0.75, timeframe };
                }
                
                // Bearish crossover with candle close below
                if (prevEma9 >= prevEma29 && ema9 < ema29 && lastCandle.close < ema9) {
                    return { type: 'PUT', strategy: 'EMA Crossover', confidence: 0.75, timeframe };
                }
                
                return null;
            },

            macdSmaCross: function(candles, timeframe) {
                if (candles.length < 30) return null;
                
                const closes = candles.map(c => c.close);
                const macd = Indicators.MACD(closes);
                const ema2 = Indicators.EMA(closes, 2);
                
                if (!macd || !ema2) return null;
                
                const lastCandle = candles[candles.length - 1];
                const smaLine = Indicators.SMA(closes, 9); // Simplified
                
                // Buy: MACD crosses above EMA2 with candle close above
                if (macd.macd > ema2 && lastCandle.close > smaLine) {
                    return { type: 'CALL', strategy: 'MACD SMA Cross', confidence: 0.7, timeframe };
                }
                
                // Sell: MACD crosses below EMA2 with candle close below
                if (macd.macd < ema2 && lastCandle.close < smaLine) {
                    return { type: 'PUT', strategy: 'MACD SMA Cross', confidence: 0.7, timeframe };
                }
                
                return null;
            },

            pinBarRejection: function(candles, timeframe) {
                if (candles.length < 5) return null;
                
                const lastCandle = candles[candles.length - 1];
                const body = Math.abs(lastCandle.close - lastCandle.open);
                const upperWick = lastCandle.high - Math.max(lastCandle.open, lastCandle.close);
                const lowerWick = Math.min(lastCandle.open, lastCandle.close) - lastCandle.low;
                
                // Bullish Pin Bar
                if (lowerWick >= body * 2 && upperWick < body) {
                    return { type: 'CALL', strategy: 'Pin Bar Rejection', confidence: 0.8, timeframe };
                }
                
                // Bearish Pin Bar
                if (upperWick >= body * 2 && lowerWick < body) {
                    return { type: 'PUT', strategy: 'Pin Bar Rejection', confidence: 0.8, timeframe };
                }
                
                return null;
            },

            engulfingFade: function(candles, timeframe) {
                if (candles.length < 5) return null;
                
                const current = candles[candles.length - 1];
                const prev = candles[candles.length - 2];
                
                const currentBody = Math.abs(current.close - current.open);
                const prevBody = Math.abs(prev.close - prev.open);
                
                // Bearish engulfing
                if (current.open > prev.close && current.close < prev.open && currentBody > prevBody * 1.5) {
                    return { type: 'PUT', strategy: 'Engulfing Fade', confidence: 0.75, timeframe };
                }
                
                // Bullish engulfing
                if (current.open < prev.close && current.close > prev.open && currentBody > prevBody * 1.5) {
                    return { type: 'CALL', strategy: 'Engulfing Fade', confidence: 0.75, timeframe };
                }
                
                return null;
            },

            insideBarBreakout: function(candles, timeframe) {
                if (candles.length < 3) return null;
                
                const current = candles[candles.length - 1];
                const mother = candles[candles.length - 2];
                
                // Check if previous was inside bar
                if (mother.high <= candles[candles.length - 3].high && 
                    mother.low >= candles[candles.length - 3].low) {
                    
                    // Bullish breakout
                    if (current.close > mother.high) {
                        return { type: 'CALL', strategy: 'Inside Bar Breakout', confidence: 0.7, timeframe };
                    }
                    
                    // Bearish breakout
                    if (current.close < mother.low) {
                        return { type: 'PUT', strategy: 'Inside Bar Breakout', confidence: 0.7, timeframe };
                    }
                }
                
                return null;
            },

            dojiMacdDivergence: function(candles, timeframe) {
                if (candles.length < 15) return null;
                
                const lastCandle = candles[candles.length - 1];
                const body = Math.abs(lastCandle.close - lastCandle.open);
                const range = lastCandle.high - lastCandle.low;
                
                // Check for doji (small body)
                if (body / range > 0.1) return null;
                
                const closes = candles.map(c => c.close);
                const macd = Indicators.MACD(closes, 5, 13, 1);
                
                if (!macd) return null;
                
                // Simplified divergence check
                if (macd.histogram > 0) {
                    return { type: 'CALL', strategy: 'Doji MACD Divergence', confidence: 0.65, timeframe };
                } else if (macd.histogram < 0) {
                    return { type: 'PUT', strategy: 'Doji MACD Divergence', confidence: 0.65, timeframe };
                }
                
                return null;
            },

            volumeSpike: function(candles, timeframe) {
                if (candles.length < 20) return null;
                
                const current = candles[candles.length - 1];
                const volumes = candles.slice(-20, -1).map(c => c.volume || 1000);
                const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
                
                const currentVolume = current.volume || 1000;
                
                // Volume spike detected
                if (currentVolume >= avgVolume * 3) {
                    const body = Math.abs(current.close - current.open);
                    const upperWick = current.high - Math.max(current.open, current.close);
                    const lowerWick = Math.min(current.open, current.close) - current.low;
                    
                    // Exhaustion top
                    if (upperWick > body && current.close < current.open) {
                        return { type: 'PUT', strategy: 'Volume Spike Exhaustion', confidence: 0.8, timeframe };
                    }
                    
                    // Exhaustion bottom
                    if (lowerWick > body && current.close > current.open) {
                        return { type: 'CALL', strategy: 'Volume Spike Exhaustion', confidence: 0.8, timeframe };
                    }
                }
                
                return null;
            }
        };

        // WebSocket Connection Management
        function connectToDerivAPI() {
            const apiToken = document.getElementById('apiToken').value.trim();
            
            if (!apiToken) {
                addLog('ERROR: Please enter your Deriv API token', 'error');
                return;
            }
            
            if (state.ws && state.connected) {
                addLog('Already connected', 'info');
                return;
            }
            
            addLog('Connecting to Deriv API...', 'info');
            
            state.ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
            
            state.ws.onopen = function() {
                addLog('WebSocket connected', 'success');
                updateConnectionStatus(true);
                showToast('ðŸ”Œ Connected', 'WebSocket connection established', 'success');
                
                // Authorize
                state.ws.send(JSON.stringify({
                    authorize: apiToken
                }));
            };
            
            state.ws.onmessage = function(msg) {
                const data = JSON.parse(msg.data);
                handleDerivMessage(data);
            };
            
            state.ws.onerror = function(error) {
                addLog('WebSocket error: ' + error.message, 'error');
                updateConnectionStatus(false);
                showToast('âŒ Connection Error', 'WebSocket connection failed', 'error');
            };
            
            state.ws.onclose = function() {
                addLog('WebSocket disconnected', 'warning');
                updateConnectionStatus(false);
                showToast('âš ï¸ Disconnected', 'Connection to Deriv API lost', 'warning');
                state.connected = false;
                state.authorized = false;
            };
        }

        function disconnectFromDerivAPI() {
            if (state.ws) {
                state.ws.close();
                state.ws = null;
                state.connected = false;
                state.authorized = false;
                updateConnectionStatus(false);
                addLog('Disconnected from Deriv API', 'info');
            }
        }

        function handleDerivMessage(data) {
            // Log all incoming messages for debugging
            if (data.msg_type) {
                console.log('Deriv message received:', data.msg_type, data);
            }
            
            if (data.error) {
                console.error('API Error:', data.error);
                addLog('API Error: ' + data.error.message, 'error');
                return;
            }
            
            // Authorization response
            if (data.authorize) {
                state.authorized = true;
                state.accountBalance = data.authorize.balance;
                state.accountCurrency = data.authorize.currency;
                console.log('Authorized:', { balance: state.accountBalance, currency: state.accountCurrency });
                updateAccountInfo();
                addLog('Authorization successful - Currency: ' + state.accountCurrency, 'success');
                
                // Subscribe to markets
                subscribeToMarkets();
                
                // Subscribe to balance updates
                state.ws.send(JSON.stringify({
                    balance: 1,
                    subscribe: 1
                }));
            }
            
            // Balance updates
            if (data.balance) {
                state.accountBalance = data.balance.balance;
                console.log('Balance update:', state.accountBalance);
                updateAccountInfo();
                flashElement('accountCard');
                showLiveIndicator('accountLive', 2000);
            }
            
            // Proposal response
            if (data.proposal) {
                handleProposal(data);
            }
            
            // Tick data
            if (data.tick) {
                updateMarketPrice(data.tick.symbol, data.tick.quote);
                processCandleUpdate(data.tick.symbol, data.tick);
            }
            
            // Candle data
            if (data.candles) {
                storeCandleData(data.echo_req.ticks_history, data.candles);
            }
            
            // Transaction updates
            if (data.transaction) {
                handleTransaction(data.transaction);
            }
            
            // Buy response
            if (data.buy) {
                handleBuyResponse(data.buy);
            }
            
            // Proposal open contract
            if (data.proposal_open_contract) {
                updateActiveTrade(data.proposal_open_contract);
            }
        }

        function subscribeToMarkets() {
            addLog('Subscribing to market data...', 'info');
            
            // Subscribe to ticks for all markets
            state.markets.forEach(market => {
                state.ws.send(JSON.stringify({
                    ticks: market,
                    subscribe: 1
                }));
                
                // Request historical candles for each timeframe
                ['60', '180', '300'].forEach(interval => {
                    state.ws.send(JSON.stringify({
                        ticks_history: market,
                        adjust_start_time: 1,
                        count: 100,
                        end: 'latest',
                        start: 1,
                        style: 'candles',
                        granularity: parseInt(interval)
                    }));
                });
            });
        }

        function updateMarketPrice(symbol, price) {
            state.marketPrices[symbol] = price;
            updateMarketGrid();
        }

        function processCandleUpdate(symbol, tick) {
            // Convert tick to candle data
            const timeframes = {
                '1m': 60,
                '3m': 180,
                '5m': 300
            };
            
            Object.keys(timeframes).forEach(tf => {
                if (!state.candleData[symbol]) {
                    state.candleData[symbol] = { '1m': [], '3m': [], '5m': [] };
                }
                
                // Simplified - in production, properly aggregate ticks to candles
                const candle = {
                    time: tick.epoch,
                    open: tick.quote,
                    high: tick.quote,
                    low: tick.quote,
                    close: tick.quote,
                    volume: 1000
                };
                
                state.candleData[symbol][tf].push(candle);
                
                // Keep last 100 candles
                if (state.candleData[symbol][tf].length > 100) {
                    state.candleData[symbol][tf].shift();
                }
            });
            
            // Analyze for signals if bot is running
            if (state.botRunning) {
                analyzeMarketSignals(symbol);
            }
        }

        function storeCandleData(symbol, candles) {
            // Store historical candle data
            // Note: Deriv API returns candles - parse and store appropriately
            addLog(`Received ${candles.length} candles for ${symbol}`, 'info');
        }

        function analyzeMarketSignals(market) {
            const timeframes = ['1m', '3m', '5m'];
            
            timeframes.forEach(tf => {
                if (!state.candleData[market] || !state.candleData[market][tf]) return;
                
                const candles = state.candleData[market][tf];
                if (candles.length < 30) return;
                
                // Run active strategies
                let signal = null;
                
                if (state.activeStrategies.ema_crossover) {
                    signal = Strategies.emaCrossover(candles, tf);
                    if (signal) addSignal(market, signal);
                }
                
                if (state.activeStrategies.macd_sma) {
                    signal = Strategies.macdSmaCross(candles, tf);
                    if (signal) addSignal(market, signal);
                }
                
                if (state.activeStrategies.pin_bar) {
                    signal = Strategies.pinBarRejection(candles, tf);
                    if (signal) addSignal(market, signal);
                }
                
                if (state.activeStrategies.engulfing) {
                    signal = Strategies.engulfingFade(candles, tf);
                    if (signal) addSignal(market, signal);
                }
                
                if (state.activeStrategies.inside_bar) {
                    signal = Strategies.insideBarBreakout(candles, tf);
                    if (signal) addSignal(market, signal);
                }
                
                if (state.activeStrategies.doji_macd) {
                    signal = Strategies.dojiMacdDivergence(candles, tf);
                    if (signal) addSignal(market, signal);
                }
                
                if (state.activeStrategies.volume_spike) {
                    signal = Strategies.volumeSpike(candles, tf);
                    if (signal) addSignal(market, signal);
                }
            });
        }

        function addSignal(market, signal) {
            // Prevent duplicate signals within 30 seconds for same market/strategy/type
            const recentDuplicate = state.signals.find(s => 
                s.market === market &&
                s.strategy === signal.strategy &&
                s.type === signal.type &&
                s.timeframe === signal.timeframe &&
                (Date.now() - s.timestamp) < 30000 // 30 seconds
            );
            
            if (recentDuplicate) {
                return; // Skip duplicate signal
            }
            
            const newSignal = {
                market,
                ...signal,
                timestamp: Date.now()
            };
            
            state.signals.unshift(newSignal);
            
            // Keep last 50 signals
            if (state.signals.length > 50) {
                state.signals.pop();
            }
            
            updateSignalList();
            
            // Execute trade if focus market matches and bot is running
            if (state.botRunning && market === state.focusMarket) {
                // Rate limit: max 1 trade per 2 seconds
                const timeSinceLastTrade = Date.now() - (state.lastTradeTime || 0);
                if (timeSinceLastTrade >= 2000) {
                    state.lastTradeTime = Date.now();
                    executeTrade(newSignal);
                } else {
                    addLog(`Trade skipped - rate limit (${(2000 - timeSinceLastTrade) / 1000}s remaining)`, 'warning');
                }
            }
        }

        function executeTrade(signal) {
            // Check risk management
            if (!checkRiskManagement()) {
                addLog('Risk limits reached - trade skipped', 'warning');
                return;
            }
            
            // Check max concurrent trades
            if (state.activeTrades.length >= parseInt(document.getElementById('maxTrades').value)) {
                addLog('Max concurrent trades reached - trade skipped', 'warning');
                return;
            }
            
            // Store signal for later reference
            state.lastSignal = signal;
            
            // Calculate stake with martingale
            let stake = parseFloat(document.getElementById('stakeAmount').value);
            
            if (document.getElementById('martingaleToggle').checked && state.martingaleStep > 0) {
                const multiplier = parseFloat(document.getElementById('martingaleMultiplier').value);
                stake = stake * Math.pow(multiplier, state.martingaleStep);
            }
            
            // Prepare trade parameters
            const durationType = document.getElementById('durationType').value;
            const durationValue = parseInt(document.getElementById('durationValue').value);
            
            // Convert duration type to Deriv API format
            let durationUnit = 'm'; // default to minutes
            if (durationType === 'ticks') durationUnit = 't';
            else if (durationType === 'seconds') durationUnit = 's';
            else if (durationType === 'minutes') durationUnit = 'm';
            
            // Get currency from account (default to USD if not available)
            const currency = state.accountCurrency || 'USD';
            
            // First, get a proposal for the trade
            const proposalParams = {
                proposal: 1,
                amount: stake,
                basis: 'stake',
                contract_type: signal.type === 'CALL' ? 'CALL' : 'PUT',
                currency: currency,
                duration: durationValue,
                duration_unit: durationUnit,
                symbol: signal.market
            };
            
            // Send proposal request
            if (state.ws && state.authorized) {
                // Store pending trade info
                if (!state.pendingTrades) state.pendingTrades = {};
                const tradeId = Date.now() + '_' + Math.random();
                
                state.pendingTrades[tradeId] = {
                    signal: signal,
                    stake: stake,
                    params: proposalParams
                };
                
                // Add passthrough to identify this proposal
                proposalParams.passthrough = { trade_id: tradeId };
                
                state.ws.send(JSON.stringify(proposalParams));
                
                addLog(`Requesting proposal for ${signal.type} trade on ${signal.market} - Strategy: ${signal.strategy}`, 'info');
            }
        }

        function handleProposal(data) {
            // Check if this is for a pending trade
            if (data.passthrough && data.passthrough.trade_id) {
                const tradeId = data.passthrough.trade_id;
                const pendingTrade = state.pendingTrades[tradeId];
                
                if (pendingTrade && data.proposal && data.proposal.id) {
                    // We have a valid proposal, now buy it
                    const buyParams = {
                        buy: data.proposal.id,
                        price: pendingTrade.stake
                    };
                    
                    state.ws.send(JSON.stringify(buyParams));
                    
                    addLog(`Executing ${pendingTrade.signal.type} trade on ${pendingTrade.signal.market} - Proposal ID: ${data.proposal.id}`, 'info');
                    
                    state.tradeRunCount++;
                    
                    // Clean up pending trade
                    delete state.pendingTrades[tradeId];
                }
            }
        }

        function checkRiskManagement() {
            if (!document.getElementById('riskManagerToggle').checked) return true;
            
            const maxLoss = parseFloat(document.getElementById('maxLoss').value);
            const maxWin = parseFloat(document.getElementById('maxWin').value);
            const minWin = parseFloat(document.getElementById('minWin').value);
            const tradeRunLimit = parseInt(document.getElementById('tradeRunLimit').value);
            
            // Check P/L limits
            if (state.todayPL <= -maxLoss) {
                stopBot();
                showToast('ðŸ›‘ Max Loss Reached', `Daily loss limit of $${maxLoss} hit. Bot stopped.`, 'error');
                addLog('Max loss reached - bot stopped', 'error');
                return false;
            }
            
            if (state.todayPL >= maxWin) {
                stopBot();
                showToast('ðŸŽ¯ Max Win Reached', `Daily profit target of $${maxWin} achieved! Bot stopped.`, 'success');
                addLog('Max win reached - bot stopped', 'success');
                return false;
            }
            
            if (state.todayPL >= minWin && state.todayPL < maxWin) {
                // Continue trading
            }
            
            // Check trade run limit
            if (state.tradeRunCount >= tradeRunLimit) {
                stopBot();
                showToast('â±ï¸ Trade Limit Reached', `Trade run limit of ${tradeRunLimit} reached. Bot stopped.`, 'warning');
                addLog('Trade run limit reached - bot stopped', 'warning');
                return false;
            }
            
            return true;
        }

        function handleBuyResponse(buyData) {
            console.log('Buy response received:', buyData);
            addLog(`Trade placed: Contract ID ${buyData.contract_id}`, 'success');
            
            // Show toast notification
            showToast(
                'ðŸš€ Trade Placed!',
                `${buyData.contract_type} on ${buyData.shortcode || buyData.symbol} - Stake: $${buyData.buy_price.toFixed(2)}`,
                'success'
            );
            
            // Add to active trades with all available data
            const trade = {
                id: buyData.contract_id,
                market: buyData.symbol || 'Unknown',
                type: buyData.contract_type,
                stake: buyData.buy_price,
                entryPrice: buyData.start_time ? (state.marketPrices[buyData.symbol] || 0) : 0,
                currentPrice: state.marketPrices[buyData.symbol] || 0,
                strategy: (state.lastSignal && state.lastSignal.strategy) || 'Unknown',
                timestamp: Date.now(),
                status: 'open',
                payout: buyData.payout || 0,
                profit: 0
            };
            
            console.log('Adding trade to active trades:', trade);
            state.activeTrades.push(trade);
            
            // Force UI update
            updateActiveTradesTable();
            updateAccountInfo();
            flashElement('activeTradesCard');
            showLiveIndicator('activeTradesLive');
            
            // Subscribe to contract updates
            if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                state.ws.send(JSON.stringify({
                    proposal_open_contract: 1,
                    contract_id: buyData.contract_id,
                    subscribe: 1
                }));
                console.log('Subscribed to contract updates:', buyData.contract_id);
            }
        }

        function updateActiveTrade(contract) {
            console.log('Contract update received:', contract);
            
            const tradeIndex = state.activeTrades.findIndex(t => t.id === contract.contract_id);
            
            if (tradeIndex !== -1) {
                // Update current price and profit
                state.activeTrades[tradeIndex].currentPrice = contract.current_spot || contract.entry_spot || state.activeTrades[tradeIndex].currentPrice;
                state.activeTrades[tradeIndex].profit = contract.profit || 0;
                
                console.log('Trade updated:', state.activeTrades[tradeIndex]);
                
                // Check if contract is closed
                if (contract.is_sold || contract.status === 'sold' || contract.status === 'won' || contract.status === 'lost') {
                    const trade = state.activeTrades[tradeIndex];
                    const profit = contract.profit || 0;
                    const isWin = profit > 0;
                    
                    console.log('Trade closed:', { profit, isWin, status: contract.status });
                    
                    // Show toast notification for closed trade
                    showToast(
                        isWin ? 'ðŸŽ‰ Trade Won!' : 'ðŸ“‰ Trade Lost',
                        `${trade.type} on ${trade.market} - P/L: ${profit >= 0 ? '+' : ''}$${profit.toFixed(2)}`,
                        isWin ? 'success' : 'error'
                    );
                    
                    // Update stats
                    state.todayPL += profit;
                    state.totalTrades++;
                    
                    console.log('Stats updated:', { todayPL: state.todayPL, totalTrades: state.totalTrades });
                    
                    if (profit > 0) {
                        state.wins++;
                        
                        // Reset martingale on win
                        if (document.getElementById('martingaleToggle').checked) {
                            const resetCondition = document.getElementById('martingaleReset').value;
                            if (resetCondition === 'win' || resetCondition === 'both') {
                                state.martingaleStep = 0;
                                addLog('Martingale reset after win', 'info');
                            }
                        }
                    } else {
                        state.losses++;
                        
                        // Increase martingale step
                        if (document.getElementById('martingaleToggle').checked) {
                            const maxSteps = parseInt(document.getElementById('martingaleSteps').value);
                            if (state.martingaleStep < maxSteps) {
                                state.martingaleStep++;
                                addLog(`Martingale step increased to ${state.martingaleStep}`, 'warning');
                            } else {
                                const resetCondition = document.getElementById('martingaleReset').value;
                                if (resetCondition === 'maxsteps' || resetCondition === 'both') {
                                    state.martingaleStep = 0;
                                    addLog('Martingale reset after max steps', 'warning');
                                }
                            }
                        }
                    }
                    
                    // Move to history
                    const historyTrade = {
                        ...trade,
                        exitPrice: contract.exit_tick || contract.current_spot || trade.currentPrice,
                        profit,
                        result: profit > 0 ? 'WIN' : 'LOSS',
                        closedAt: Date.now()
                    };
                    
                    state.tradeHistory.unshift(historyTrade);
                    state.activeTrades.splice(tradeIndex, 1);
                    
                    console.log('Trade moved to history. Active trades:', state.activeTrades.length, 'History:', state.tradeHistory.length);
                    
                    updateTradeHistoryTable();
                    flashElement('tradeHistoryCard');
                    showLiveIndicator('tradeHistoryLive');
                    
                    updateAccountInfo();
                    flashElement('accountCard');
                    showLiveIndicator('accountLive');
                    
                    addLog(`Trade closed: ${profit > 0 ? 'WIN' : 'LOSS'} - P/L: $${profit.toFixed(2)}`, profit > 0 ? 'success' : 'error');
                }
                
                // Always update the active trades table to show current P/L
                updateActiveTradesTable();
            } else {
                console.log('Trade not found in active trades:', contract.contract_id);
            }
        }

        function handleTransaction(transaction) {
            // Handle balance updates
            if (transaction.action === 'buy' || transaction.action === 'sell') {
                const oldBalance = state.accountBalance;
                state.accountBalance = transaction.balance_after;
                
                const balanceChange = state.accountBalance - oldBalance;
                
                if (Math.abs(balanceChange) > 0.01) {
                    flashElement('accountCard');
                    showLiveIndicator('accountLive', 2000);
                }
                
                updateAccountInfo();
            }
        }

        // UI Update Functions
        function updateConnectionStatus(connected) {
            state.connected = connected;
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
            }
        }

        // Toast Notification System
        function showToast(title, message, type = 'info') {
            const toastContainer = document.getElementById('toastContainer');
            
            const icons = {
                success: 'âœ“',
                error: 'âœ•',
                warning: 'âš ',
                info: 'â„¹'
            };
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-icon">${icons[type] || icons.info}</div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <div class="toast-close" onclick="this.parentElement.remove()">Ã—</div>
            `;
            
            toastContainer.appendChild(toast);
            
            // Play sound
            playNotificationSound(type);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                toast.classList.add('removing');
                setTimeout(() => toast.remove(), 300);
            }, 5000);
        }

        // Sound notification system
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        function playNotificationSound(type) {
            try {
                if (!audioCtx) audioCtx = new AudioContext();
                
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                // Different sounds for different notification types
                if (type === 'success') {
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime + 0.1);
                } else if (type === 'error') {
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime + 0.1);
                } else if (type === 'warning') {
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                } else {
                    oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
                }
                
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.2);
            } catch (e) {
                // Silent fail if audio not supported
            }
        }

        function flashElement(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.classList.add('update-flash');
                setTimeout(() => element.classList.remove('update-flash'), 500);
            }
        }

        function showLiveIndicator(elementId, duration = 3000) {
            const indicator = document.getElementById(elementId);
            if (indicator) {
                indicator.style.display = 'inline-flex';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, duration);
            }
        }

        function updateAccountInfo() {
            console.log('Updating account info:', {
                balance: state.accountBalance,
                todayPL: state.todayPL,
                totalTrades: state.totalTrades,
                wins: state.wins,
                losses: state.losses,
                activeTrades: state.activeTrades.length
            });
            
            document.getElementById('balance').textContent = `$${state.accountBalance.toFixed(2)}`;
            document.getElementById('todayPL').textContent = `$${state.todayPL.toFixed(2)}`;
            document.getElementById('todayPL').className = state.todayPL >= 0 ? 'stat-value profit' : 'stat-value loss';
            document.getElementById('totalTrades').textContent = state.totalTrades;
            
            const winRate = state.totalTrades > 0 ? (state.wins / state.totalTrades * 100).toFixed(1) : 0;
            document.getElementById('winRate').textContent = `${winRate}%`;
            document.getElementById('activeTrades').textContent = state.activeTrades.length;
            document.getElementById('botStatus').textContent = state.botRunning ? 'RUNNING' : 'STOPPED';
        }

        function updateMarketGrid() {
            const grid = document.getElementById('marketGrid');
            
            grid.innerHTML = state.markets.map(market => {
                const price = state.marketPrices[market] || '---';
                const isActive = market === state.focusMarket;
                
                // Check for recent signal
                const recentSignal = state.signals.find(s => 
                    s.market === market && 
                    Date.now() - s.timestamp < 60000 && 
                    s.timeframe === state.selectedTimeframe
                );
                
                return `
                    <div class="market-card ${isActive ? 'active' : ''}" onclick="setFocusMarket('${market}')">
                        <div class="market-name">${market}</div>
                        <div class="market-price">${typeof price === 'number' ? price.toFixed(price > 100 ? 2 : 5) : price}</div>
                        ${recentSignal ? `<div class="signal-badge ${recentSignal.type.toLowerCase()}">${recentSignal.type}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function updateSignalList() {
            const signalList = document.getElementById('signalList');
            
            if (state.signals.length === 0) {
                signalList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">Waiting for signals...</div>';
                return;
            }
            
            signalList.innerHTML = state.signals.slice(0, 20).map(signal => {
                const timeAgo = Math.floor((Date.now() - signal.timestamp) / 1000);
                return `
                    <div class="signal-item">
                        <div class="signal-header">
                            <span class="signal-market">${signal.market}</span>
                            <span class="signal-badge ${signal.type.toLowerCase()}">${signal.type}</span>
                        </div>
                        <div class="signal-details">
                            ${signal.strategy} â€¢ ${signal.timeframe} â€¢ ${timeAgo}s ago â€¢ Confidence: ${(signal.confidence * 100).toFixed(0)}%
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateActiveTradesTable() {
            const tbody = document.getElementById('activeTradesTable');
            
            console.log('Updating active trades table. Count:', state.activeTrades.length);
            
            if (state.activeTrades.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; color: var(--text-secondary);">No active trades</td></tr>';
                return;
            }
            
            tbody.innerHTML = state.activeTrades.map(trade => {
                const currentProfit = trade.profit || 0;
                const profitClass = currentProfit >= 0 ? 'profit' : 'loss';
                const timeElapsed = Math.floor((Date.now() - trade.timestamp) / 1000);
                
                return `
                <tr>
                    <td>${trade.id.substring(0, 8)}...</td>
                    <td>${trade.market}</td>
                    <td>${trade.type}</td>
                    <td>$${trade.stake.toFixed(2)}</td>
                    <td>${trade.entryPrice.toFixed(5)}</td>
                    <td>${trade.currentPrice.toFixed(5)}</td>
                    <td class="${profitClass}">${currentProfit >= 0 ? '+' : ''}$${currentProfit.toFixed(2)}</td>
                    <td>${trade.strategy}</td>
                    <td>${timeElapsed}s</td>
                </tr>
            `;
            }).join('');
            
            // Update active trades count
            document.getElementById('activeTrades').textContent = state.activeTrades.length;
        }

        function updateTradeHistoryTable() {
            const tbody = document.getElementById('tradeHistoryTable');
            
            console.log('Updating trade history table. Count:', state.tradeHistory.length);
            
            if (state.tradeHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; color: var(--text-secondary);">No trade history</td></tr>';
                return;
            }
            
            tbody.innerHTML = state.tradeHistory.slice(0, 50).map(trade => {
                const time = new Date(trade.closedAt).toLocaleTimeString();
                return `
                    <tr>
                        <td>${time}</td>
                        <td>${trade.market}</td>
                        <td>${trade.type}</td>
                        <td>$${trade.stake.toFixed(2)}</td>
                        <td>${trade.entryPrice.toFixed(5)}</td>
                        <td>${trade.exitPrice.toFixed(5)}</td>
                        <td class="${trade.profit >= 0 ? 'profit' : 'loss'}">$${trade.profit.toFixed(2)}</td>
                        <td>${trade.strategy}</td>
                        <td>${trade.result}</td>
                    </tr>
                `;
            }).join('');
        }

        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('systemLog');
            const time = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<span class="log-time">[${time}]</span><span>${message}</span>`;
            
            logContainer.insertBefore(logEntry, logContainer.firstChild);
            
            // Keep last 100 logs
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Control Functions
        function setFocusMarket(market) {
            state.focusMarket = market;
            updateMarketGrid();
            addLog(`Focus market set to ${market}`, 'info');
        }

        function selectTimeframe(tf) {
            state.selectedTimeframe = tf;
            
            // Update tab UI
            document.querySelectorAll('.timeframe-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateMarketGrid();
        }

        function startBot() {
            if (!state.connected || !state.authorized) {
                showToast('âŒ Connection Required', 'Please connect to Deriv API first', 'error');
                addLog('Please connect to Deriv API first', 'error');
                return;
            }
            
            state.botRunning = true;
            updateAccountInfo();
            showToast('âœ… Bot Started', 'Automated trading is now active', 'success');
            addLog('Trading bot started', 'success');
        }

        function stopBot() {
            state.botRunning = false;
            updateAccountInfo();
            showToast('â¸ï¸ Bot Stopped', 'Automated trading has been paused', 'warning');
            addLog('Trading bot stopped', 'warning');
        }

        function resetBot() {
            state.martingaleStep = 0;
            state.tradeRunCount = 0;
            state.todayPL = 0;
            state.totalTrades = 0;
            state.wins = 0;
            state.losses = 0;
            
            updateAccountInfo();
            flashElement('accountCard');
            showToast('ðŸ”„ Bot Reset', 'Statistics and counters have been reset', 'info');
            addLog('Bot reset completed', 'info');
        }

        function clearHistory() {
            state.tradeHistory = [];
            state.signals = [];
            updateTradeHistoryTable();
            updateSignalList();
            showToast('ðŸ—‘ï¸ History Cleared', 'Trade history and signals removed', 'info');
            addLog('History cleared', 'info');
        }

        // Strategy toggle handling
        document.querySelectorAll('.strategy-toggle').forEach(toggle => {
            toggle.addEventListener('change', function() {
                const strategy = this.dataset.strategy;
                state.activeStrategies[strategy] = this.checked;
                addLog(`Strategy ${strategy} ${this.checked ? 'enabled' : 'disabled'}`, 'info');
            });
        });

        // Initialize
        updateMarketGrid();
        updateAccountInfo();
        
        // Periodic UI updates
        setInterval(() => {
            if (state.connected) {
                updateMarketGrid();
                updateActiveTradesTable();
            }
        }, 1000);
    </script>
</body>
</html>
